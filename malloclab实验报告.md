# malloclab实验报告

#2022201895 于佳鑫

## 整体介绍

在这个版本中，我采用了高效而轻量的方法——显式空闲改造链表和`LIFO`排列方式，并结合`best-fit`作为分配策略，同时采用替代版`realloc`技术。我将基础版显式空闲链表中的指针改为偏移量，这样在64位机器下前驱和后继的占用空间从8字节减少到4字节，最小块大小也从24降为16。这一改动不仅使得本方法适用于64/32位机器，还增强了其可移植性。

本实验参考了这个链接[🔗](https://github.com/zhuozhiyongde/Introduction-To-Computer-System-2023Fall-PKU/tree/main/07-Malloc-Lab)里面的优化思路，但具体实现并不相同。

## 具体分析

为了减少阅读量，这里主要介绍一下比较值得讲的地方。

### block的设置

为了加速空闲块的查找，采用显式空闲链表是合理的。使用分离链表虽然查找速度比较快，但是占用存储空间比较大，所以只采用了一个链表。同时为了实现方便，采用了LIFO策略。链表的`prev`和`next`指针改成了相对于root的地址偏移量。特别地，如果上一个空闲块是root，则设置该块的prev = 0；如果是最后一个空闲块，设置next为0；

### mm_init的设置

因为block的设置，我们的显式空闲链表不需要开头的prev和next指针，只需要一个root作为空闲块的锚点。root只需要一个字节，所以直接放到用于对其的第一个字节，减少开销。

### fine-tuning

- 在测试案例4中，申请2个4095然后释放，申请1个8190然后释放的循环，实际最大块面积并不大，所以在init的时候不应该开太大的块。从测试结果可以看出，去掉`init`开辟的块大小可以使得总分增加一分。

- 因为该版本使用显式空闲链表之后搜索速度大大加快，所以每次增加的块的大小可以相应减小。把`chunksize`从4096减小到1024.

- 在realloc中，为了增大利用率，每次先释放需要增大的块，再进行`malloc`，这样可以避免每次都开一个新的大块。

- 可以看到，在binary测试文件中，交错分配了很多的 448 字节的块与 64 字节的块，但随后只释放了其中 448 字节的块，然后又分配了很多的 512 字节的块。若不调整分配块的大小，则会导致 448 字节的块被释放后完全无法用于 512 字节块的分配，从而导致内存利用率下降。我们特判上调这些范围的大小，以获得更好的内存利用率。
- 在9，10测试点中，先申请一个大块和一个小块，随后进行`realloc`大块a(增大了一个小于小块的量），再释放掉之前的小块，这样的循环，大概循环了几千次。这样就会因为在`realloc`的时候，因为小块的存在不能直接在后面增加。所以为了提前避免掉小块的阻碍，检测到这个小块的时候，分配两个小块，再释放掉地址低的那一个，这样就会在大块上面留出增长的空间，随后用先`free`后`malloc`来解决。

## 总结

### 其他优化思路

- 这个版本的代码还有一些优化思路，比如课本上提到的推迟合并就是一个优化的方向。在找不到块时再进行合并，这样或许能减少一些时间开销，或许在本实验中或许不适用，是一个可以探索的方向。

- 对`realloc`进行优化，现在这个`realloc`虽然比较简单，但是不断地`mm_move`还是降低了效率，如果采用先判断后面是否有剩余空间，如果有的话直接分配增加的大小，这样就会提高速率。

### 收获

在本次实验中，我更加深刻理解了`malloc`的底层逻辑，对各种分配方法都有了深入的了解。同时，本次实验大量的调试找bug的工作也让我更加熟悉了`gdb`调试。本实验`example.c`中优美的代码风格也很值得学习。总之，本次实验收获满满。